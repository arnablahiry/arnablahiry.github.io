<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: #fafafa;
      overflow: hidden;
      position: relative;
      cursor: crosshair;
    }

    #runner {
      position: absolute;
      width: 80px;        /* constrain width */
      height: auto;       /* preserve aspect ratio */
      max-height: 80px;   /* cap height so it doesn't grow too large */
      user-select: none;
      pointer-events: none; /* so mouse doesn't hover directly */
      transition: transform 0.08s linear;
      transform-origin: center center;
      /* fast back-and-forth rotation between -5deg and +5deg */
      animation: twitch 50ms linear infinite;
      display: block;
    }
    @keyframes twitch{
      0% { transform: rotate(-10deg); }
      50% { transform: rotate(10deg); }
      100% { transform: rotate(-10deg); }
    }
  </style>
</head>
<body>

<img id="runner" src="images/hp/snitch.png" />

<script>
  const img = document.getElementById("runner");
  const speed = 1;                 // random drifting speed
  const fleeDistance = 120;        // mouse proximity trigger (px)
  const dartDistance = 150;         // dart away distance (px)

  let x = window.innerWidth / 2;
  let y = window.innerHeight / 2;
  // state for slow (clickable) mode
  let slowMode = false;
  let mouseEnabled = true; // whether proximity fleeing is active
  let animating = false;
  let smoothRaf = null;

  // Place the image initially
  img.style.left = x + "px";
  img.style.top = y + "px";

  // Do NOT start slow mode immediately. Instead, enable slow mode when the
  // user has been actively moving the mouse for ~20 seconds continuously.
  // This listener tracks continuous mouse movement and triggers slow mode.
  let movementTracking = false;
  let movementStart = 0;
  let lastMove = 0;
  let movementChecker = null;
  let slowTriggered = false;

  document.addEventListener('mousemove', (e) => {
    // Always update lastMove timestamp for tracking (separate from proximity logic)
    const now = Date.now();
    lastMove = now;

    if (slowTriggered) return; // already triggered

    if (!movementTracking) {
      movementTracking = true;
      movementStart = now;
      // Start a checker to ensure movement is continuous (no >1s pauses)
      movementChecker = setInterval(() => {
        const now2 = Date.now();
        // if no recent move within 1s, treat as pause and reset
        if (now2 - lastMove > 1000) {
          movementTracking = false;
          movementStart = 0;
          clearInterval(movementChecker);
          movementChecker = null;
          return;
        }
        // if user has been moving continuously for 20s, trigger slow mode
        if (now2 - movementStart >= 10000) {
          slowTriggered = true;
          movementTracking = false;
          clearInterval(movementChecker);
          movementChecker = null;
          // start slow mode for 30s (same as previous default)
          startSlowMode(5 * 1000);
        }
      }, 500);
    }
  });

  // --- RANDOM DRIFT ---
  function randomDrift() {
    // Only apply small random drift when not performing a smooth animation
    if (!animating) {
        x += (Math.random() - 0.5) * speed;
        y += (Math.random() - 0.5) * speed;

      // Keep image inside screen
      x = Math.max(0, Math.min(window.innerWidth - img.width, x));
      y = Math.max(0, Math.min(window.innerHeight - img.height, y));

      img.style.left = x + "px";
      img.style.top = y + "px";

      // If we accidentally hit a corner, flee in a different direction
      checkCornerAndFlee();
    }

    requestAnimationFrame(randomDrift);
  }

  randomDrift();

  // Smooth move helper: interpolates x/y over a duration (ms) with ease-out
  function smoothMoveTo(tx, ty, duration = 220) {
    if (smoothRaf) cancelAnimationFrame(smoothRaf);
    animating = true;
    const start = performance.now();
    const sx = x;
    const sy = y;

    function step(now) {
      const t = Math.min(1, (now - start) / duration);
      // easeOutCubic
      const eased = 1 - Math.pow(1 - t, 3);
      x = sx + (tx - sx) * eased;
      y = sy + (ty - sy) * eased;
      img.style.left = x + "px";
      img.style.top = y + "px";
      if (t < 1) {
        smoothRaf = requestAnimationFrame(step);
      } else {
        animating = false;
        smoothRaf = null;
      }
    }

    smoothRaf = requestAnimationFrame(step);
  }

  // --- SLOW MODE / CLICKABLE MODE ---
  function startSlowMode(durationMs){
    slowMode = true;
    mouseEnabled = false;

    // In slow mode: disable proximity fleeing and allow the user to click
    // the snitch. Do not modify drift speed or twitch animation here.
    img.style.pointerEvents = 'auto';
    img.style.cursor = 'pointer';
    img.addEventListener('click', onClickRunner);

    // schedule end of slow mode
    setTimeout(() => {
      slowMode = false;
      mouseEnabled = true;
      img.style.pointerEvents = 'none';
      img.style.cursor = '';
      img.removeEventListener('click', onClickRunner);
    }, durationMs);
  }

  function onClickRunner(e){
    // brief scale feedback when clicked
    img.style.transition = 'transform 160ms ease';
    img.style.transform = 'scale(1.08) rotate(0deg)';
    setTimeout(()=>{
      img.style.transform = '';
    }, 160);
  }

  // --- PERIODIC RANDOM DART ---
  // On top of the continuous drift and mouse-triggered flee, make the
  // image occasionally dart a short fixed distance in a random direction
  // so it appears jumpy by default.
  function scheduleRandomDart(){
    // pick a delay depending on slowMode
    // slowMode: ~20s ±5s (20000 ± 5000 ms)
    // normal: 300-900ms as before
    const delay = slowMode ? (20000 + (Math.random() * 10000 - 5000)) : (300 + Math.random() * 600);
    setTimeout(() => {
      // random angle
      const angle = Math.random() * Math.PI * 2;
  const effectiveDart = slowMode ? (dartDistance * 0.25) : dartDistance;
  const dx = Math.cos(angle) * effectiveDart;
  const dy = Math.sin(angle) * effectiveDart;
      // Compute target and smoothly move there
      const targetX = Math.max(0, Math.min(window.innerWidth - img.width, x + dx));
      const targetY = Math.max(0, Math.min(window.innerHeight - img.height, y + dy));
      // use a longer duration in slow mode so the motion is gentler
      const dur = slowMode ? 800 : 220;
      smoothMoveTo(targetX, targetY, dur);

      // If we landed in a corner after the dart, ensure we escape (will be called after move completes)
      setTimeout(checkCornerAndFlee, dur + 40);

      // schedule next random dart
      scheduleRandomDart();
    }, delay);
  }

  scheduleRandomDart();

  // --- DART AWAY WHEN MOUSE GETS CLOSE ---
  document.addEventListener("mousemove", (e) => {
    if (!mouseEnabled) return; // proximity disabled during slow mode
    const dx = x - e.clientX;
    const dy = y - e.clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < fleeDistance) {
      // Normalize vector
      const ux = dx / dist;
      const uy = dy / dist;
      // Compute target position and smoothly move away
      const targetX = Math.max(0, Math.min(window.innerWidth - img.width, x + ux * dartDistance));
      const targetY = Math.max(0, Math.min(window.innerHeight - img.height, y + uy * dartDistance));
      const dur = slowMode ? 500 : 260;
      smoothMoveTo(targetX, targetY, dur);

      // ensure we aren't stuck in a corner after fleeing (run after animation)
      setTimeout(checkCornerAndFlee, dur + 40);
    }
  });

  // --- CORNER HANDLER ---
  function checkCornerAndFlee(){
    const margin = 6; // px tolerance to consider "at the edge"
    const maxX = Math.max(0, window.innerWidth - img.width);
    const maxY = Math.max(0, window.innerHeight - img.height);

    const atLeft = x <= margin;
    const atRight = x >= (maxX - margin);
    const atTop = y <= margin;
    const atBottom = y >= (maxY - margin);

    if ((atLeft || atRight) && (atTop || atBottom)) {
      // Determine the corner coordinates
      const cx = atLeft ? 0 : maxX;
      const cy = atTop ? 0 : maxY;

      // Vector away from the corner
      let dx = x - cx;
      let dy = y - cy;
      let dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < 1) {
        // degenerate: pick a random direction
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle);
        dy = Math.sin(angle);
        dist = 1;
      }

      const ux = dx / dist;
      const uy = dy / dist;

  // Move away: use a larger flee amount to ensure we get off the corner
  const fleeAmount = Math.max(dartDistance, fleeDistance) * 1.2;
  const targetX = Math.max(0, Math.min(maxX, x + ux * fleeAmount));
  const targetY = Math.max(0, Math.min(maxY, y + uy * fleeAmount));
  smoothMoveTo(targetX, targetY, 300);
    }
  }
</script>

</body>
</html>
